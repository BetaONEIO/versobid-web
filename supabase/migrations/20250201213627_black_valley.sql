-- Drop existing trigger and function\nDROP TRIGGER IF EXISTS on_auth_user_created ON auth.users;
\nDROP FUNCTION IF EXISTS handle_new_user();
\nDROP FUNCTION IF EXISTS create_profile_safely();
\n\n-- Create function to safely create profile with better error handling\nCREATE OR REPLACE FUNCTION create_profile_safely(\n  user_id UUID,\n  user_email TEXT,\n  user_username TEXT,\n  user_full_name TEXT\n) RETURNS boolean AS $$\nDECLARE\n  final_username TEXT;
\n  attempt_count INTEGER := 0;
\n  MAX_ATTEMPTS CONSTANT INTEGER := 3;
\nBEGIN\n  -- Initialize username\n  final_username := COALESCE(\n    user_username,\n    REGEXP_REPLACE(SPLIT_PART(user_email, '@', 1), '[^a-zA-Z0-9_]', '_', 'g')\n  );
\n  \n  -- Ensure username meets requirements\n  IF length(final_username) < 3 THEN\n    final_username := final_username || FLOOR(RANDOM() * 900 + 100)::text;
\n  END IF;
\n  \n  LOOP\n    EXIT WHEN attempt_count >= MAX_ATTEMPTS;
\n    BEGIN\n      INSERT INTO public.profiles (\n        id,\n        email,\n        username,\n        full_name,\n        created_at,\n        is_admin,\n        avatar_url,\n        shipping_address,\n        payment_setup,\n        onboarding_completed\n      ) VALUES (\n        user_id,\n        user_email,\n        final_username,\n        COALESCE(user_full_name, final_username),\n        NOW(),\n        false,\n        null,\n        null,\n        false,\n        false\n      );
\n      \n      RETURN true;
\n      \n    EXCEPTION \n      WHEN unique_violation THEN\n        -- Only retry for username violations\n        IF attempt_count < MAX_ATTEMPTS THEN\n          final_username := REGEXP_REPLACE(final_username, '_\\d+$', '');
 -- Remove any existing numbers\n          final_username := final_username || '_' || (floor(random() * 9000 + 1000))::text;
\n          attempt_count := attempt_count + 1;
\n          CONTINUE;
\n        END IF;
\n      WHEN OTHERS THEN\n        -- Log other errors\n        INSERT INTO auth_errors (\n          user_id,\n          email,\n          error,\n          details\n        ) VALUES (\n          user_id,\n          user_email,\n          SQLERRM,\n          jsonb_build_object(\n            'state', SQLSTATE,\n            'attempt', attempt_count,\n            'username', final_username\n          )\n        );
\n        RETURN false;
\n    END;
\n  END LOOP;
\n  \n  -- Log failure after max attempts\n  INSERT INTO auth_errors (\n    user_id,\n    email,\n    error,\n    details\n  ) VALUES (\n    user_id,\n    user_email,\n    'Failed to create profile after maximum attempts',\n    jsonb_build_object(\n      'max_attempts', MAX_ATTEMPTS,\n      'final_username', final_username\n    )\n  );
\n  \n  RETURN false;
\nEND;
\n$$ LANGUAGE plpgsql SECURITY DEFINER;
\n\n-- Create improved user creation handler\nCREATE OR REPLACE FUNCTION handle_new_user()\nRETURNS trigger\nSECURITY DEFINER\nSET search_path = public\nLANGUAGE plpgsql\nAS $$\nDECLARE\n  success boolean;
\nBEGIN\n  -- Attempt to create profile\n  success := create_profile_safely(\n    NEW.id,\n    NEW.email,\n    NEW.raw_user_meta_data->>'username',\n    NEW.raw_user_meta_data->>'full_name'\n  );
\n\n  IF NOT success THEN\n    RAISE WARNING 'Failed to create profile for user: %', NEW.email;
\n  END IF;
\n\n  RETURN NEW;
\nEND;
\n$$;
\n\n-- Create error logging table if it doesn't exist\nCREATE TABLE IF NOT EXISTS auth_errors (\n  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),\n  user_id UUID,\n  email TEXT,\n  error TEXT,\n  details JSONB,\n  created_at TIMESTAMPTZ DEFAULT now()\n);
\n\n-- Recreate trigger\nCREATE TRIGGER on_auth_user_created\n  AFTER INSERT ON auth.users\n  FOR EACH ROW\n  EXECUTE FUNCTION handle_new_user();
\n\n-- Ensure RLS is enabled\nALTER TABLE profiles ENABLE ROW LEVEL SECURITY;
\n\n-- Drop existing policies safely\nDO $$ \nBEGIN\n    DROP POLICY IF EXISTS "profiles_select" ON profiles;
\n    DROP POLICY IF EXISTS "profiles_insert" ON profiles;
\n    DROP POLICY IF EXISTS "profiles_update" ON profiles;
\nEXCEPTION \n    WHEN undefined_object THEN NULL;
\nEND $$;
\n\n-- Create simplified policies\nCREATE POLICY "profiles_select"\n  ON profiles\n  FOR SELECT\n  TO public\n  USING (true);
\n\nCREATE POLICY "profiles_insert"\n  ON profiles\n  FOR INSERT\n  TO service_role\n  WITH CHECK (true);
\n\nCREATE POLICY "profiles_update"\n  ON profiles\n  FOR UPDATE\n  TO authenticated\n  USING (auth.uid() = id)\n  WITH CHECK (auth.uid() = id);
\n\n-- Ensure proper grants\nGRANT USAGE ON SCHEMA public TO anon, authenticated, service_role;
\nGRANT ALL ON profiles TO service_role;
\nGRANT SELECT ON profiles TO anon;
\nGRANT SELECT, UPDATE ON profiles TO authenticated;
\n\n-- Create unique indexes\nDROP INDEX IF EXISTS idx_profiles_email;
\nDROP INDEX IF EXISTS idx_profiles_username;
\nCREATE UNIQUE INDEX idx_profiles_email ON profiles(email);
\nCREATE UNIQUE INDEX idx_profiles_username ON profiles(username);
;
