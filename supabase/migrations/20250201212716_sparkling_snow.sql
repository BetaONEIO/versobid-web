-- Drop existing trigger and function\nDROP TRIGGER IF EXISTS on_auth_user_created ON auth.users;
\nDROP FUNCTION IF EXISTS handle_new_user();
\n\n-- Create improved function to handle new user creation with better error handling\nCREATE OR REPLACE FUNCTION handle_new_user()\nRETURNS trigger\nSECURITY DEFINER\nSET search_path = public\nLANGUAGE plpgsql\nAS $$\nDECLARE\n  username text;
\n  full_name text;
\n  retry_count integer := 0;
\n  max_retries constant integer := 3;
\nBEGIN\n  -- Extract username and full_name from metadata with better defaults\n  username := COALESCE(\n    NEW.raw_user_meta_data->>'username',\n    REGEXP_REPLACE(SPLIT_PART(NEW.email, '@', 1), '[^a-zA-Z0-9_]', '_', 'g')\n  );
\n  \n  full_name := COALESCE(\n    NEW.raw_user_meta_data->>'full_name',\n    username\n  );
\n\n  -- Insert profile with retry logic\n  WHILE retry_count < max_retries LOOP\n    BEGIN\n      INSERT INTO public.profiles (\n        id,\n        email,\n        username,\n        full_name,\n        created_at,\n        is_admin,\n        avatar_url,\n        shipping_address,\n        payment_setup,\n        onboarding_completed\n      ) VALUES (\n        NEW.id,\n        NEW.email,\n        username,\n        full_name,\n        NOW(),\n        false,\n        null,\n        null,\n        false,\n        false\n      );
\n      \n      -- If successful, exit the loop\n      EXIT;
\n      \n    EXCEPTION \n      WHEN unique_violation THEN\n        -- Only handle username conflicts\n        IF retry_count < max_retries THEN\n          username := username || '_' || (floor(random() * 9000 + 1000))::text;
\n          retry_count := retry_count + 1;
\n          CONTINUE;
\n        ELSE\n          RAISE EXCEPTION 'Failed to create unique username after % attempts', max_retries;
\n        END IF;
\n      WHEN OTHERS THEN\n        -- Log other errors and re-raise\n        RAISE WARNING 'Error creating profile for user %: % (SQLSTATE: %)', NEW.id, SQLERRM, SQLSTATE;
\n        RAISE;
\n    END;
\n  END LOOP;
\n\n  RETURN NEW;
\nEND;
\n$$;
\n\n-- Recreate trigger with AFTER INSERT to ensure auth user exists\nCREATE TRIGGER on_auth_user_created\n  AFTER INSERT ON auth.users\n  FOR EACH ROW\n  EXECUTE FUNCTION handle_new_user();
\n\n-- Ensure RLS is enabled\nALTER TABLE profiles ENABLE ROW LEVEL SECURITY;
\n\n-- Drop all existing policies\nDO $$ \nBEGIN\n    DROP POLICY IF EXISTS "profiles_read_policy" ON profiles;
\n    DROP POLICY IF EXISTS "profiles_insert_policy" ON profiles;
\n    DROP POLICY IF EXISTS "profiles_update_policy" ON profiles;
\n    DROP POLICY IF EXISTS "allow_read_all_profiles" ON profiles;
\n    DROP POLICY IF EXISTS "allow_service_role_insert" ON profiles;
\n    DROP POLICY IF EXISTS "allow_users_update_own" ON profiles;
\n    DROP POLICY IF EXISTS "profiles_read_all" ON profiles;
\n    DROP POLICY IF EXISTS "profiles_insert_service" ON profiles;
\n    DROP POLICY IF EXISTS "profiles_update_own" ON profiles;
\nEXCEPTION \n    WHEN undefined_object THEN NULL;
\nEND $$;
\n\n-- Create new simplified policies\nCREATE POLICY "profiles_select"\n  ON profiles\n  FOR SELECT\n  TO public\n  USING (true);
\n\nCREATE POLICY "profiles_insert"\n  ON profiles\n  FOR INSERT\n  TO service_role\n  WITH CHECK (true);
\n\nCREATE POLICY "profiles_update"\n  ON profiles\n  FOR UPDATE\n  TO authenticated\n  USING (auth.uid() = id)\n  WITH CHECK (auth.uid() = id);
\n\n-- Ensure proper grants\nGRANT USAGE ON SCHEMA public TO anon, authenticated, service_role;
\nGRANT ALL ON profiles TO service_role;
\nGRANT SELECT ON profiles TO anon;
\nGRANT SELECT, UPDATE ON profiles TO authenticated;
\n\n-- Create or update indexes\nDROP INDEX IF EXISTS idx_profiles_email;
\nDROP INDEX IF EXISTS idx_profiles_username;
\nCREATE UNIQUE INDEX idx_profiles_email ON profiles(email);
\nCREATE UNIQUE INDEX idx_profiles_username ON profiles(username);
;
